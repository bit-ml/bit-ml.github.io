{"path":"blog/post/pretrained-atari-agents","templateID":2,"sharedPropsHashes":{"galleries":"m6C23"},"localProps":{"post":{"data":{"slug":"pretrained-atari-agents","authors":"Florin Gogianu","categories":"blog, reinforcement-learning","featured_img":"/galleries/atari_agents_2022/collage.png","date":"May-05-2022","title":":joystick: Pretrained Atari Agents","id":0},"messages":[],"history":["./content/collections/posts/atari_agents_2022.md","content/collections/posts/atari_agents_2022.html"],"cwd":"/home/fgogianu/Code/github/bit-ml","contents":"<h1>üïπÔ∏è Pretrained Atari Agents</h1>\n<p>Releasing trained models in computer vision and natural language processing has been a major source of progress for the research in these fields and a significant catalyst for the adaption of deep learning models in the industry. By comparison, RL agents pretrained on otherwise resource and time intensive benchmarks such as Arcade Learning Environment are rather hard to come by.</p>\n<p>Today, our research group within Bitdefender is making available over 2Ô∏è‚É£5Ô∏è‚É£,0Ô∏è‚É£0Ô∏è‚É£0Ô∏è‚É£ agents trained on 60 games in the Arcade Learning Environment. We hope the diversity and the quality of these trained models will help spur new research in multi-task and imitation learning and contribute to the state of reproducibility in deep reinforcement learning.</p>\n<p>The performance of these agents closely matches figures published in the literature and have been used as strong baselines in published and unpublished work. The agents included in this release are Munchausen-DQN and Adam-optimised DQN that compare favourably with more complex agents as well as a C51 agent whose performance matches or exceeds the results reported in the paper that introduced it. We provide three independent training runs for each agent-game combination with the exception of on agent for which we only provide two seeds. We plan to continue releasing new models.</p>\n<p>Another feature of this release is the extreme ease of experimenting with the agents. No RL frameworks are required, the dependency list is kept to a minimum, the code is self-contained and takes just two files, making it a breeze to quickly load a checkpoint, visualize the gameplay at high resolution and record it. The simplicity of the code also makes it possible to easily modify the scripts for your own purposes. Converting these models for use in other deep learning frameworks should also be possible.</p>\n<p>We encourage you coming with suggestions of how to make this repository of trained models better and more useful. Relevant links:</p>\n<ul>\n<li><img src=\"/galleries/atari_agents_2022/octocat.svg\" alt=\"octocat\"> ¬† <a href=\"https://github.com/floringogianu/atari-agents#trained-atari-agents\">floringogianu/atari-agents</a></li>\n<li>üìÇ ¬† <a href=\"https://share.bitdefender.com/s/qCF7jFxkgx2qJeT\">download models</a></li>\n</ul>\n<h2>How we trained the agents</h2>\n<p>A major reason for deciding to publish these models is the sheer amount of time required to run DQN-style algorithms on the Atari benchmark. This is especially difficult for small labs.</p>\n<p>For this release we used \"only\" 20 to 40 GPUs (a wide assortment ranging from GTX Titan to newer RTX consumer models) from our cluster at Bitdefender, for a combined running time of about two months for learning all the agents. Considering  a full run on ALE requires 3 seeds <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>√ó</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">√ó</span></span></span></span></span> 60 games and a single DQN-style agent takes a bit over one week this might seem a bit surprising. What made this possible is that we figured out early that you could launch three to four DQN processes on a single GPU provided the replay buffer is stored in the system RAM. The penalty incurred in terms of wall clock times is easily offset by parallelization in this case.</p>\n<p>This is one of the reason our agents have been trained using our own PyTorch implementations and while the code used is not readily available we consider publishing it if there is demand for it.</p>\n<h3>A word on training and evaluation protocols</h3>\n<p>There are two common training and evaluation protocols encountered in the literature. We named them <code>classic</code> and <code>modern</code> across this project:</p>\n<ul>\n<li><code>classic</code>: it originates from (Mnih, 2015)<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> Nature paper and it mostly appears in DeepMind papers.</li>\n<li><code>modern</code>: it originates from (Machado, 2017)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> and a variation of it was adopted by Dopamine<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup>. Since then it started to show up more often in recent papers.</li>\n</ul>\n<p>The main two differences between the two are the way stochasticity is induced in the environment and how the loss of a life is treated.</p>\n<p>The current crop of agents is summarized below.</p>\n<div class=\"wide-content\"></div>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Algorithm</th>\n<th>Protocol</th>\n<th align=\"center\">Games</th>\n<th align=\"center\">Seeds</th>\n<th align=\"left\">Observations</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><strong>DQN</strong></td>\n<td><code>modern</code></td>\n<td align=\"center\">60</td>\n<td align=\"center\">3</td>\n<td align=\"left\">DQN agent using the settings from <a href=\"https://github.com/google/dopamine/blob/master/dopamine/jax/agents/dqn/configs/dqn.gin\">dopamine</a>. It's optimised with Adam and uses MSE instead of Huber loss. <strong>A surprisingly strong agent on this protocol</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>M-DQN</strong></td>\n<td><code>modern</code></td>\n<td align=\"center\">60</td>\n<td align=\"center\">3</td>\n<td align=\"left\">DQN above but using the <strong>Munchausen trick</strong>. Even stronger performance.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>C51</strong></td>\n<td><code>classic</code></td>\n<td align=\"center\">28/57</td>\n<td align=\"center\">3</td>\n<td align=\"left\">Closely follows the original paper<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>DQN Adam</strong></td>\n<td><code>classic</code></td>\n<td align=\"center\">28/57</td>\n<td align=\"center\">2</td>\n<td align=\"left\">A DQN agent trained according to the Rainbow paper<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>. The exact settings and plots can be found in our paper<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>.</td>\n</tr>\n</tbody>\n</table>\n<p>Right off-the bat you can notice that on the <code>classic</code> protocol there are only 28 games out of the usual 57. We trained the two agents on this protocol over one year ago using the now deprecated <code>atari-py</code> project which officially provided the ALE Python bindings in OpenAI's Gym. Unfortunately the package came with a large number of ROMs that are not supported by the current, official, <a href=\"https://github.com/mgbellemare/Arcade-Learning-Environment\">ale-py</a> library. The agents trained on the <code>modern</code> protocol (as well as the code we provide for visualising agents) all use the new <code>ale-py</code>. Therefore we decided against providing support for the older library event if it meant dropping half of the trained models. A great resource for reading about this issue is Jesse's Farebrother <a href=\"https://brosa.ca/blog/ale-release-v0.7/#rom-management\">ALE v0.7 release notes</a>. Importantly, we found out about the issue while checking the performance of the trained models on the new <code>ale-py</code> back-end and we provide plots showing the remaining 28 agents perform as expected (<a href=\"https://github.com/floringogianu/atari-agents/blob/main/imgs/c51_g28_confirmation.png\">C51_classic</a>, <a href=\"https://github.com/floringogianu/atari-agents/blob/main/imgs/dqn_g28_confirmation.png\">DQN_classic</a>).</p>\n<h2>How many checkpoints?</h2>\n<p>An agent trained on 200M frames usually produces 200 checkpoints times the number of training seeds. In order not to make the download size overly large <strong>we only include 51 checkpoints per training run</strong>. These are sampled geometrically, with denser checkpoints towards the end of the training. This results in the last 20 checkpoints of the full 200 (last 10% of the training run) and then sparser checkpoints towards the beginning of the run, with only 10 out of 51 from the first half. It looks a bit like this:</p>\n<p><img src=\"/galleries/atari_agents_2022/sampling.png\" alt=\"checkpoint sampling\"></p>\n<p>Note it's not mandatory the best performing checkpoint is included since on some combinations of algorithms and agents the peak performance occurs earlier in training. However this sampling should characterize fairly well the performance of an agent most of the time.</p>\n<p>‚ùó‚úã If <a href=\"https://github.com/floringogianu/atari-agents/issues\">requested</a>, we can provide the full list of checkpoints for a given agent.</p>\n<p>Agents have been trained using PyTorch and the models are stored as compressed <a href=\"https://pytorch.org/tutorials/recipes/recipes/what_is_state_dict.html\">state_dict</a> pickle files. Since the networks used on ALE are fairly simple these could easily be converted for use in other deep learning frameworks.</p>\n<h2>Just how well trained are these agents?</h2>\n<p>Our PyTorch implementation of DQN trained using Adam on the <code>modern</code> protocol compares favourable to the exact same agent trained using Dopamine. The plots below have been generated using the tools provided by <a href=\"https://github.com/google-research/rliable\">rliable</a>.</p>\n<p><img src=\"/galleries/atari_agents_2022/rliable_comparison.png\" alt=\"dopamine_vs_pytorch\"></p>\n<p>A detailed discussion about the performance of DQN + Adam and C51 trained on the <code>classic</code> protocol can be found in our paper<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>, where we used these checkpoints as baselines.</p>\n<h2>References</h2>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-2\"><a href=\"https://www.nature.com/articles/nature14236\">Mnih, 2015. _Human-level control through deep reinforcement learning</a><a href=\"#fnref-2\" class=\"footnote-backref\">‚Ü©</a></li>\n<li id=\"fn-1\"><a href=\"https://arxiv.org/abs/1709.06009\">Machado, 2017. <em>Revisiting the Arcade Learning Environment...</em></a><a href=\"#fnref-1\" class=\"footnote-backref\">‚Ü©</a></li>\n<li id=\"fn-6\"><a href=\"http://arxiv.org/abs/1812.06110\">Castro, 2018. <em>Dopamine: A Research Framework for Deep RL</em></a><a href=\"#fnref-6\" class=\"footnote-backref\">‚Ü©</a></li>\n<li id=\"fn-4\"><a href=\"https://arxiv.org/abs/1710.02298\">Hessel, 2017. <em>Combining Improvements in Deep RL</em></a><a href=\"#fnref-4\" class=\"footnote-backref\">‚Ü©</a></li>\n<li id=\"fn-5\"><a href=\"https://www.semanticscholar.org/paper/Spectral-Normalisation-for-Deep-Reinforcement-an-Gogianu-Berariu/cf04c05f69022f71b60c7b7252af94f11cad5ef1\">Gogianu, 2017. <em>Spectral Normalisation...</em></a><a href=\"#fnref-5\" class=\"footnote-backref\">‚Ü©</a></li>\n<li id=\"fn-3\"><a href=\"http://proceedings.mlr.press/v70/bellemare17a.html\">Bellemare, 2017. <em>A distributional perspective...</em></a><a href=\"#fnref-3\" class=\"footnote-backref\">‚Ü©</a></li>\n</ol>\n</div>\n"}}}
